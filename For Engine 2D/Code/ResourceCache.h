#pragma once

namespace FE2D {
	class FOR_API ResourceCache : public ResourceModule<ResourceCache> {
	public:
		ResourceCache(ResourceManager* load_resourceManager) {
			setResourceManager(load_resourceManager);
		}
		~ResourceCache() = default;
	private:
		// pointer of resource
		using _Resource = IResource*;
		using _Metadata = std::filesystem::path;

		// typeid(T).hash_code
		using _TypeIndex = size_t;
		// generated by ResourceManager
		using _ItemIndex = size_t;

		using _StoredResourceArray = std::unordered_map<_ItemIndex, _Resource>;
		using _StoredMetadataArray = std::unordered_map<_ItemIndex, _Metadata>;

		std::unordered_map<_TypeIndex, _StoredResourceArray> m_StoredResources;
		std::unordered_map<_TypeIndex, _StoredMetadataArray> m_StoredMetadata;
	public:
		std::unordered_map<_TypeIndex, _StoredResourceArray>& get_resource_array() {
			return m_StoredResources;
		}
		std::unordered_map<_TypeIndex, _StoredMetadataArray>& get_metadata_array() {
			return m_StoredMetadata;
		}

		const std::unordered_map<_TypeIndex, _StoredResourceArray>& get_resource_array()const {
			return m_StoredResources;
		}
		const std::unordered_map<_TypeIndex, _StoredMetadataArray>& get_metadata_array()const {
			return m_StoredMetadata;
		}

		void set_resource(_Resource resource, _TypeIndex hash_code, _ItemIndex index) {
			m_StoredResources[hash_code].emplace(index, resource);
		}
		void set_metadata(const _Metadata& metadata, _TypeIndex hash_code, _ItemIndex index) {
			m_StoredMetadata[hash_code].emplace(index, metadata);
		}

		_Resource get_resource(_TypeIndex hash_code, _ItemIndex index);
		std::optional<_Metadata> get_metadata(_TypeIndex hash_code, _ItemIndex index);

		void remove_resource(_TypeIndex hash_code, _ItemIndex index);
		void remove_metadata(_TypeIndex hash_code, _ItemIndex index);

		void clear() {
			m_StoredResources.clear();
			m_StoredMetadata.clear();
		}
	};
}